// Generated by CoffeeScript 1.3.3
(function() {
  var Items, canonicalListName, itemMapping, listModel, newListModel, reset_data, samples, viewModel, vm;

  Items = new Meteor.Collection('items');

  samples = (typeof exports !== "undefined" && exports !== null ? exports : this).samples || [];

  reset_data = function() {
    var i, newid, sample, _i, _len;
    Items.remove({
      list: (typeof vm.listName === "function" ? vm.listName() : void 0) || 'Sample'
    });
    for (i = _i = 0, _len = samples.length; _i < _len; i = ++_i) {
      sample = samples[i];
      newid = Items.insert({
        item: sample.item,
        archived: sample.archived,
        list: (typeof vm.listName === "function" ? vm.listName() : void 0) || 'Shopping-List',
        idx: sample.idx
      });
    }
  };

  if (Meteor.is_client) {
    itemMapping = {
      item: {
        create: function(options) {
          var itemObject, observable;
          itemObject = options.parent;
          observable = ko.observable(options.data);
          itemObject.isMoving = ko.observable(false);
          itemObject.indent = ko.observable(typeof this.idx === "function" ? this.idx().split('.').length : void 0);
          itemObject.hasUnsavedChanges = false;
          itemObject.item.subscribe(function() {
            return itemObject.hasUnsavedChanges = true;
          });
          itemObject.archived.subscribe(function() {
            return itemObject.hasUnsavedChanges = true;
          });
          itemObject.idx.subscribe(function() {
            return itemObject.hasUnsavedChanges = true;
          });
          itemObject.canMoveHere = ko.computed(function() {
            return vm.vm().isMoving() && !this.isMoving();
          }, itemObject);
          itemObject.doIndent = function() {
            var itm, prevIdx, _i, _len, _ref;
            prevIdx = (_ref = vm.vm().prevItem(itemObject)) != null ? _ref.idx() : void 0;
            for (_i = 0, _len = items.length; _i < _len; _i++) {
              itm = items[_i];
              itm.idx(itm.idx().replace(itemObject.idx(), prevIdx + '.001'));
            }
            vm.vm().saveAll();
          };
          itemObject.doOutdent = function() {
            var parent;
            parent = Items.findOne(itemObject.parent());
            Items.update(itemObject._id(), {
              $set: {
                parent: parent != null ? parent.parent : void 0,
                ancestors: parent != null ? parent.ancestors : void 0
              }
            });
            return Items.update({
              ancestors: itemObject._id()
            }, {
              $pull: {
                ancestors: parent != null ? parent._id : void 0
              }
            }, {
              multi: true
            });
          };
          itemObject.save = function() {
            return Items.update(itemObject._id(), {
              $set: {
                item: itemObject.item()
              }
            });
          };
          itemObject.unarchive = function() {
            Items.update({
              ancestors: itemObject._id()
            }, {
              $set: {
                archived: false
              }
            }, {
              multi: true
            });
            return Items.update(itemObject._id(), {
              $set: {
                archived: false
              }
            });
          };
          itemObject.remove = function() {
            if (itemObject.archived()) {
              Items.remove({
                ancestors: itemObject._id()
              });
              return Items.remove(itemObject._id());
            } else {
              Items.update({
                ancestors: itemObject._id()
              }, {
                $set: {
                  archived: true
                }
              }, {
                multi: true
              });
              return Items.update(itemObject._id(), {
                $set: {
                  archived: true
                }
              });
            }
          };
          return observable;
        }
      }
    };
    newListModel = function(parent) {
      var _this = this;
      this.name = ko.observable('');
      this.saveOnEnter = function(model, event) {
        if (event.which !== 13) {
          return true;
        }
        model.save();
        return false;
      };
      this.goShopping = function() {
        window.location.href = 'http://' + window.location.host + '/#!Shopping-List';
        window.location.reload();
      };
      this.save = function() {
        Session.set('listName', canonicalListName(_this.name()));
        window.location.href = 'http://' + window.location.host + '/#!' + canonicalListName(_this.name());
        window.location.reload();
      };
    };
    listModel = function(parent) {
      var actionSetTemplate, actionSets, checkKeydownBindings, createNewItem, focusNextOnDown, focusPreviousOnUp, indentOn3Spaces, isMoving, items, itemsToMoveCount, itemsToMoveIndex, moveHere, moveItem, outdentOnBackspaceAndEmpty, prevItem, rotateActionSets, saveAll, saveOnEnter, _this;
      _this = this;
      items = ko.meteor.find(Items, {
        list: parent.listName()
      }, {
        sort: {
          idx: 1
        }
      }, itemMapping);
      isMoving = ko.observable(false);
      itemsToMoveIndex = ko.observable();
      itemsToMoveCount = ko.observable();
      actionSets = ko.observableArray(['archiveRemove', 'indentOutdent']);
      prevItem = function(model) {
        return items()[items.indexOf(model) - 1];
      };
      saveAll = function() {
        var itm, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = items.length; _i < _len; _i++) {
          itm = items[_i];
          if (itm.hasUnsavedChanges) {
            _results.push(Items.update(itm._id(), {
              $set: {
                item: itm.item(),
                archived: itm.archived(),
                idx: itm.idx()
              }
            }));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
      createNewItem = function() {
        var newid;
        newid = Items.insert({
          item: '',
          archived: false,
          sortOrder: items().length,
          list: vm.listName(),
          parent: '',
          ancestors: []
        });
        return Meteor.defer(function() {
          return $("." + newid + " input")[0].focus();
        });
      };
      indentOn3Spaces = function(model, event) {
        var myId;
        if (event.which !== 32) {
          return;
        }
        if (model.item().substr(0, 2) !== '  ') {
          return;
        }
        model.item(model.item().substring(2));
        model.doIndent();
        myId = model._id();
        return Meteor.defer(function() {
          return $("." + myId + " input")[0].focus();
        });
      };
      outdentOnBackspaceAndEmpty = function(model, event) {
        var focusid, myId, _ref;
        if (event.which !== 8) {
          return;
        }
        if (model.item() !== '') {
          return;
        }
        model.save();
        if (!model.parent()) {
          focusid = model._id();
          if (model.archived()) {
            focusid = (_ref = items()[items.indexOf(model) - 1]) != null ? _ref._id() : void 0;
          }
          model.remove();
          return Meteor.defer(function() {
            return $("." + focusid + " input").each(function() {
              return $(this).focus();
            });
          });
        } else {
          model.doOutdent();
          myId = model._id();
          return Meteor.defer(function() {
            return $("." + myId + " input")[0].focus();
          });
        }
      };
      checkKeydownBindings = function(model, event) {
        indentOn3Spaces(model, event);
        outdentOnBackspaceAndEmpty(model, event);
        saveOnEnter(model, event);
        focusPreviousOnUp(model, event);
        focusNextOnDown(model, event);
        return true;
      };
      focusPreviousOnUp = function(model, event) {
        var prevId, _ref;
        if (event.which !== 38) {
          return;
        }
        prevId = (_ref = items()[items.indexOf(model) - 1]) != null ? _ref._id() : void 0;
        model.save();
        if (prevId) {
          return Meteor.defer(function() {
            return $("." + prevId + " input")[0].focus();
          });
        }
      };
      focusNextOnDown = function(model, event) {
        var nextId, _ref;
        if (event.which !== 40) {
          return;
        }
        nextId = (_ref = items()[items.indexOf(model) + 1]) != null ? _ref._id() : void 0;
        model.save();
        if (nextId) {
          return Meteor.defer(function() {
            return $("." + nextId + " input")[0].focus();
          });
        }
      };
      saveOnEnter = function(model, event) {
        var newid, nextOrder, pos, _ref;
        if (event.which !== 13) {
          return true;
        }
        model.save();
        pos = items.indexOf(model);
        nextOrder = ((_ref = items()[pos + 1]) != null ? _ref.sortOrder() : void 0) || model.sortOrder() + 2;
        newid = Items.insert({
          item: '',
          archived: false,
          sortOrder: model.sortOrder() + ((nextOrder - model.sortOrder()) / 2),
          list: vm.listName(),
          parent: typeof model.parent === "function" ? model.parent() : void 0,
          ancestors: typeof model.ancestors === "function" ? model.ancestors() : void 0
        });
        Meteor.defer(function() {
          return $("." + newid + " input")[0].focus();
        });
        return false;
      };
      moveItem = function(data) {
        var countOfItems, itm, pos, _i, _len, _ref;
        itemsToMoveIndex(items.indexOf(data));
        data.isMoving(true);
        pos = items.indexOf(data);
        countOfItems = 1;
        _ref = items.slice(pos + 1);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          itm = _ref[_i];
          if (itm.indent() <= data.indent()) {
            break;
          }
          countOfItems++;
          itm.isMoving(true);
        }
        isMoving(true);
        return itemsToMoveCount(countOfItems);
      };
      moveHere = function(data) {
        var cutItems, i, id, itm, pastePos, rootItemOldIndent, rootItemToMove, tail, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2;
        cutItems = items.splice(itemsToMoveIndex(), itemsToMoveCount());
        rootItemToMove = cutItems[0];
        rootItemOldIndent = rootItemToMove.indent();
        rootItemToMove.ancestors(data.ancestors().slice(0));
        rootItemToMove.ancestors.push(data._id());
        rootItemToMove.parent(data.parent());
        _ref = cutItems.slice(1);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          itm = _ref[_i];
          itm.ancestors.splice(0, rootItemOldIndent);
          _ref1 = rootItemToMove.ancestors.slice(0).reverse();
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            id = _ref1[_j];
            itm.ancestors.unshift(id);
          }
        }
        pastePos = items.indexOf(data) + 1;
        tail = items.splice(pastePos, 9e9);
        for (_k = 0, _len2 = cutItems.length; _k < _len2; _k++) {
          itm = cutItems[_k];
          items.push(itm);
        }
        for (_l = 0, _len3 = tail.length; _l < _len3; _l++) {
          itm = tail[_l];
          items.push(itm);
        }
        isMoving(false);
        _ref2 = items();
        for (i = _m = 0, _len4 = _ref2.length; _m < _len4; i = ++_m) {
          itm = _ref2[i];
          Items.update(itm._id(), {
            $set: {
              sortOrder: i,
              parent: itm.parent(),
              ancestors: itm.ancestors()
            }
          });
          itm.isMoving(false);
          prevItem = itm;
        }
      };
      rotateActionSets = function() {
        return actionSets.push(actionSets.shift());
      };
      actionSetTemplate = ko.computed(function() {
        return actionSets()[0] + 'Template';
      });
      return {
        items: items,
        createNewItem: createNewItem,
        checkKeydownBindings: checkKeydownBindings,
        saveOnEnter: saveOnEnter,
        moveItem: moveItem,
        isMoving: isMoving,
        moveHere: moveHere,
        actionSetTemplate: actionSetTemplate,
        rotateActionSets: rotateActionSets
      };
    };
    viewModel = function() {
      var _this = this;
      this.listName = ko.observable(canonicalListName(Session.get('listName')));
      this.showingJSON = ko.observable(false);
      this.json = ko.observable('');
      this.templateToUse = function() {
        if (_this.listName()) {
          return 'socialist';
        } else {
          return 'newList';
        }
      };
      this.vm = ko.observable(this.listName() === '' ? new newListModel(this) : new listModel(this));
      this.listName.subscribe(function() {
        if (_this.listName() === '') {
          return _this.vm(new newListModel(_this));
        } else {
          return _this.vm(new listModel(_this));
        }
      });
      this.resetData = function() {
        return reset_data();
      };
      this.showJSON = function() {
        if (_this.vm().items) {
          _this.json(ko.mapping.toJSON(_this.vm().items));
        }
        return _this.showingJSON(true);
      };
      this.newList = function() {
        Session.set('listName', '');
        return true;
      };
      this.delArchived = function() {
        return Items.remove({
          list: this.listName(),
          archived: true
        });
      };
      this.archiveAll = function() {
        if (_this.vm().items) {
          Items.update({
            list: vm.listName
          }, {
            $set: {
              archived: true
            }
          }, {
            multi: true
          });
        }
      };
    };
    canonicalListName = function(name) {
      return name.replace(/[^-A-z0-9\s]*/g, '').replace(/\s+/g, '-');
    };
    Session.set('listName', window.location.hash.replace('#!', '') || '');
    vm = new viewModel();
    Meteor.startup(function() {
      return ko.applyBindings(vm);
    });
  }

  if (Meteor.is_server) {
    Meteor.methods({
      indent: function(idx, prevIdx) {
        var itemWithChildren, itm, startsWithIdx, _i, _len, _results;
        startsWithIdx = new RegExp("^" + (idx.replace('.', '\\.')) + ".*", "i");
        itemWithChildren = Items.find({
          idx: startsWithIdx
        });
        _results = [];
        for (_i = 0, _len = itemWithChildren.length; _i < _len; _i++) {
          itm = itemWithChildren[_i];
          _results.push(Items.update(itm._id, {
            $set: {
              idx: itm.idx.replace(startsWithIdx, prevIdx + '.001')
            }
          }, {
            multi: true
          }));
        }
        return _results;
      }
    });
    Meteor.startup(function() {
      if (Items.find().count() === 0) {
        return reset_data();
      }
    });
  }

}).call(this);
